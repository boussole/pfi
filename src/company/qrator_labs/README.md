# Задача 1: убрать все циклы из смешанного графа

Дан граф из <= 50 нод, часть ребер ориентированные, часть нет.
Требуется всем неориентированным ребрам задать ориентацию так, чтобы в итоговом графе не было циклов.
Граф задается матрицей смежности.

Формально: написать метод

```
/**
 * \in     матрица смежности входного графа;
 * \out    матрица смежности получившегося графа без циклов.
 * 
 * \return false - если задача не имеет решений, true - если имеет.
 */
bool solve(const vector < vector < bool >  > & in, vector < vector < bool > > & out):
```

Метод должен работать < 1c на современном процессоре, используя 1 поток.
Можно считать, что входные данные корректны:

```
in.size() > 0 && in.size() == in[0].size() && in[i].size() == in[j].size() && in[i][i] == false \forall i,j < in.size().
```

# Задача 2: реализовать ThreadPool без использования C++ 11/14

Реализовать ThreadPool (на C++ под linux без использования C++ 11/14):
 * конструктор имеет один параметр - число воркеров, которые будут выполнять задачи.
 * метод Enqueue имеет два параметра - объект(ссылку на объект), описывающий задачу, которую надо будет выполнить (например абстрактного типа с методом .do()) и приоритет(пусть всего будет три приоритета - low, normal, high).
 * метод Stop() - ожидает завершения выполняемых (в данный момент) задач, после чего убивает воркеры и возвращает управление.
 
Enqueue добавляет задачи в очередь на выполнение и возвращает true (если до этого не был вызван Stop - в этом случае Enqueue возвращает false).

Приоритеты обрабатываются следующим образом:
 * low-задачи не выполняются никогда, пока в очереди есть хотя бы одна задача с другим приоритетом.
 * на 3 high-задачи выполняется 1 normal-задача.

Данная логика относится только к выборке задачи из очереди, уже запущенные задачи приоритизировать не требуется.

# Задача 3: поиск локального минимума в массиве

Дан массив различных целых чисел.
Надо найти индекс локального минимума в этом массиве.
Необходимо реализовать алгоритм с минимальной асимптотической сложностью.
Локальный минимум - это такой элемент массива a_i, что a_{i-1} > a_i < a_{i+1}. Для начала и конца массива, соответственно: a0 < a1 и a_n < a_{n-1}. 


# Задача 4: привести массив к унимодальной форме

Дан массив различных целых чисел.
Мы хотим отсортировать его следующим образом (унимодальная форма):

```
a0 > a1 > a2 > … > a_{k-1} > a_k < a_{k+1} < a_{k+2} < … a_N.
```

При этом единственная допустимая операция: поменять местами два соседних элемента.
Программа должна работать не более 1 секунды на массивах длиной не более 1000 элементов.

Необходимо написать функцию возвращающую минимально необходимое количество операций, которые приводят массив к данному виду.

```
int n_swaps(const vector<int>& a);
```

