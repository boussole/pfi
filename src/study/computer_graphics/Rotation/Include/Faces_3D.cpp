//---------------------------------------------------------------------------
#pragma hdrstop
#include "Faces_3D.h"
#include "Matrix_3D.cpp"
#include "math.hpp"
#include "math.h"
#include "HeadFile.h"
//---------------------------------------------------------------------------
#pragma package(smart_init)
//---------------------------------------------------------------------------
/*/используемые типы данных/*/
/*/-----------------------------------------------------------------------/*/
  //тип данных для описания треугольной грани полигональной поверхности
  //индексами ее вершин в массиве всех вершин
  struct TFace
      {
         UInt VI[3]; //индексы вершин
         //координата X ближайшей к плоскости проекций вершины
         double maxX;
         //координаты цвета, лежат в диапазоне [0, 1]
         double R, G, B;
      };

  //описание плоскости грани с помощью четырех коэффициентов
  //ее уравнения Ax+By+Cz+D=0
//typedef double TPlane[4];
  typedef TVertex TPlane;

  //описание вектора в пространстве
//typedef double TVector[4];
   typedef TVertex TVector;

//Вычисляет коэффициенты уравнения плоскости Ax+By+Cz+D=0, проходящей через
//три обычные точки (с координатой H <> 0) V0, V1 и V2. Если эти точки лежат
//на одной прямой, то все коэффициенты будут нулевыми.
//Уравнение нормализуется таким образом, что длина вектора нормали
//N={A,B,C} к плоскости равна 1: |N|=1
void GetPlaneEquation(const TVertex, const TVertex, const TVertex, TPlane);

//Вычисляет цвет грани F, лежащей в плоскости P при освещении
//источником света, расположенном в направлении вектора Light
TColor GetFaceColor(const TFace, const TPlane, const TVector);

//Рисует грань F на холсте Canvas. Через параметр VP передается
//массив координат проекций всех вершин поверхности. Координаты
//X и Y каждой проекции должны быть равны ее экранным координатам.
//Через параметр P передается уравнение плоскости грани, а через
//Light -- единичный вектор указывающий, где в пространстве
//находится источник света
void DrawFace(const TCanvas *, const TVertex *VP, const TFace, const TPlane, const TVector);

//Определение знака
int Sign(double);
//определяет положение точки V (обычной или лежащей в бесконечности)
//относительно плоскости P:
// - если точка лежит на плоскости, возвращает 0;
// - если точка лежит с той стороны от плоскости, в которую направлен
//ее вектор нормали, то возвращает +1
// - если точки лежит с противоположной стороны, то возвращает -1
int DetectPointSide(const TVertex, const TPlane);
/*/------------------------------------------------------------------------/*/
//implemenation
//-------------------------------------------------------------------------
//Вычисляет коэффициенты уравнения плоскости Ax+By+Cz+D=0, проходящей через
//три обычные точки (с координатой H <> 0) V0, V1 и V2. Если эти точки лежат
//на одной прямой, то все коэффициенты будут нулевыми.
//Уравнение нормализуется таким образом, что длина вектора нормали
//N={A,B,C} к плоскости равна 1: |N|=1
void GetPlaneEquation(const TVertex V0, const TVertex V1, const TVertex V2, TPlane P)
   {
      double x01, y01, z01, x12, y12, z12;
      double L;
  //вычислим координаты вектора V0V1
  x01 = V1[0]/V1[3] - V0[0]/V0[3];
  y01 = V1[1]/V1[3] - V0[1]/V0[3];
  z01 = V1[2]/V1[3] - V0[2]/V0[3];
  //вычислим координаты вектора V1V2
  x12 = V2[0]/V2[3] - V1[0]/V1[3];
  y12 = V2[1]/V2[3] - V1[1]/V1[3];
  z12 = V2[2]/V2[3] - V1[2]/V1[3];

  //вычислим координаты вектора нормали к плоскости, равного векторному
  //произведению векторов V0V1 и V1V2. Они будут равны первым трем
  //коэффициентам уравнения: X = A, Y = B, Z = C
  P[0] = (y01*z12 - y12*z01); //A = X
  P[1] = (z01*x12 - z12*x01); //B = Y
  P[2] = (x01*y12 - x12*y01); //C = Z

  //найдем коэффициент D, подставив в уравнение координаты точки V0:
  //D = -A*X0 - B*Y0 - C*Z0
  P[3] = -(P[0]*V0[0] + P[1]*V0[1] + P[2]*V0[2]) / V0[3];

  //вычислим длину вектора нормали к плоскости
  L = sqrt(P[0]*P[0] + P[1]*P[1] + P[2]*P[2]);
  //Нормализуем уравнение плоскости, разделив все его коэффициенты на L.
  //В результате вектор N={a,b,c} будет иметь единичную длину
  if (L != 0)
      {P[0] = P[0]/L; P[1] = P[1]/L; P[2]= P[2]/L; P[3] = P[3]/L;}
   }

//Вычисляет цвет грани F, лежащей в плоскости P при освещении
//источником света, расположенном в направлении вектора Light
TColor GetFaceColor(const TFace F, const TPlane _P, const TVector Light)
   {
      double I;
      double cosAlpha;
      //вычислим скалярное произведение вектора нормали и вектора
      //плоскости, равное косинусу угла Альфа между ними
      cosAlpha = _P[0]*Light[0] + _P[1]*Light[1] + _P[2]*Light[2];
      //вычислим интенсивность отраженного света от грани
      I = 100 + Modul(154 * cosAlpha);
      //вычислим цвет грани в соответствии с его координатами R,G,B
      return(RGB(Round(I*F.R), Round(I*F.G), Round(I*F.B)));
   }

//Рисует грань F на холсте Canvas. Через параметр VP передается
//массив координат проекций всех вершин поверхности. Координаты
//X и Y каждой проекции должны быть равны ее экранным координатам.
//Через параметр P передается уравнение плоскости грани, а через
//Light -- единичный вектор указывающий, где в пространстве
//находится источник света
void DrawFace(const TCanvas *, const TVertex *VP, const TFace, const TPlane, const TVector);
//-----------------------------------------------------------------
void DrawFace(const TCanvas *Canvas, const TVertex *VP, const TFace F, const TPlane PP, const TVector _Light)
{
   TPoint FS[3];
   for (int i = 0; i < 3; i++)
      {
         Canvas->Pen->Color = GetFaceColor(F, PP, _Light);
         //Canvas->Pen->Color = clWhite;
         Canvas->Brush->Color = Canvas->Pen->Color;
         FS[i].x = Round(VP [F.VI[i]] [0]);
         FS[i].y = Round(VP [F.VI[i]] [1]);
      }
  Canvas->Polygon(FS, 2);
}
//-----------------------------------------------------------------
int Sign(double x)
   {
      if (x == 0) {return 0;}
      else
         if (x > 0) {return 1;}
         else {return  (-1);}
   }
//определяет положение точки V (обычной или лежащей в бесконечности)
//относительно плоскости P:
// - если точка лежит на плоскости, возвращает 0;
// - если точка лежит с той стороны от плоскости, в которую направлен
//ее вектор нормали, то возвращает +1
// - если точки лежит с противоположной стороны, то возвращает -1
int DetectPointSide(const TVertex V, const TPlane _P)
   {
      int s;
      //знак положения точки относительно плоскости определяется так:
      //Знак = Sign(A*X+B*Y+C*Z+D*H) при H >= 0
      //Знак = -Sign(A*X+B*Y+C*Z+D*H) при H < 0
      s = Sign(int((_P[0]*V[0]+_P[1]*V[1]+_P[2]*V[2]+_P[3]*V[3])*1000)/1000);
      if (V[3] < 0)  {return (- s);}
      else {return s;}
   }
/*/-----------------------------------------------------------------------/*/
